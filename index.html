<!DOCTYPE html>
<html dir="rtl">
<head>
    <meta charset="UTF-8">
    <title>Ù„Ø¹Ø¨Ø© Ø§Ù„ØªØ·Ø§Ø¨Ù‚ Ø§Ù„Ø«Ù„Ø§Ø«ÙŠ - Ø§Ù„Ø¹Ù…Ù„Ø§Øª Ø§Ù„Ù…Ø¹Ø¯Ù†ÙŠØ©</title>
    <style>
        * {
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            user-select: none;
        }
        body {
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            padding: 15px;
        }
        .game-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 40px;
            padding: 25px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            max-width: 700px;
            width: 100%;
        }
        .level-badge {
            text-align: center;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 12px 25px;
            border-radius: 60px;
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 20px;
        }
        .stats {
            display: flex;
            justify-content: space-around;
            background: #f0f0f0;
            padding: 15px;
            border-radius: 20px;
            margin-bottom: 20px;
        }
        .stat-item {
            text-align: center;
        }
        .stat-value {
            font-size: 28px;
            font-weight: bold;
            color: #764ba2;
        }
        .boosters-panel {
            display: flex;
            justify-content: center;
            gap: 30px;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 30px;
            margin-bottom: 20px;
        }
        .booster {
            width: 80px;
            height: 80px;
            background: white;
            border-radius: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            cursor: pointer;
            border: 3px solid transparent;
        }
        .booster.active {
            border-color: gold;
            background: #fff9e6;
        }
        .booster-icon {
            font-size: 32px;
        }
        .board-container {
            display: flex;
            justify-content: center;
            background: #f0f0f0;
            padding: 25px;
            border-radius: 40px;
        }
        .board {
            display: inline-grid;
            gap: 10px;
        }
        /* ØªØµÙ…ÙŠÙ… Ø§Ù„Ø¹Ù…Ù„Ø© Ø§Ù„Ù…Ø¹Ø¯Ù†ÙŠØ© */
        .cell {
            width: 65px;
            height: 65px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #ffd966, #b8860b);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            font-weight: bold;
            color: #333;
            text-shadow: 0 2px 4px rgba(255,255,255,0.5);
            box-shadow: 0 8px 0 #8b6508, 0 10px 15px rgba(0,0,0,0.3);
            cursor: pointer;
            transition: 0.1s;
            border: 2px solid #f1c40f;
            position: relative;
        }
        .cell.selected {
            transform: scale(1.1);
            box-shadow: 0 0 0 4px gold, 0 10px 0 #8b6508, 0 15px 20px black;
        }
        .cell.obstacle {
            background: radial-gradient(circle at 30% 30%, #95a5a6, #4a4a4a);
            box-shadow: 0 8px 0 #2c3e50;
            border-color: #7f8c8d;
        }
        .cell.obstacle::after {
            content: "â›”";
            font-size: 28px;
            color: white;
        }
        .cell.ice {
            position: relative;
        }
        .cell.ice::after {
            content: "â„ï¸";
            position: absolute;
            top: -10px;
            right: -10px;
            font-size: 22px;
            filter: drop-shadow(0 2px 2px rgba(0,0,0,0.3));
        }
        .cell.hint {
            animation: hintPulse 1s infinite;
            box-shadow: 0 0 0 4px #00ff88, 0 10px 0 #8b6508, 0 15px 20px black;
        }
        @keyframes hintPulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 25px;
        }
        button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 60px;
            font-size: 18px;
            cursor: pointer;
        }
        .reward-message {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #f5af19;
            color: white;
            padding: 15px 30px;
            border-radius: 60px;
            display: none;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="level-badge" id="levelNumber">Ø§Ù„Ù…Ø³ØªÙˆÙ‰ 1 / 20</div>
        <div class="stats">
            <div class="stat-item"><span class="stat-value" id="score">0</span><div>Ø§Ù„Ù†Ù‚Ø§Ø·</div></div>
            <div class="stat-item"><span class="stat-value" id="target">500</span><div>Ø§Ù„Ù‡Ø¯Ù</div></div>
        </div>
        <div class="boosters-panel">
            <div class="booster" onclick="selectBooster('arrow')" id="boosterArrow">
                <div class="booster-icon">â¬…ï¸â¡ï¸</div>
                <div id="arrowCount">0</div>
            </div>
            <div class="booster" onclick="selectBooster('bomb')" id="boosterBomb">
                <div class="booster-icon">ğŸ’£</div>
                <div id="bombCount">0</div>
            </div>
        </div>
        <div class="board-container">
            <div class="board" id="board"></div>
        </div>
        <div class="controls">
            <button onclick="prevLevel()">â—€ Ø³Ø§Ø¨Ù‚</button>
            <button onclick="resetLevel()">Ø¥Ø¹Ø§Ø¯Ø©</button>
            <button onclick="nextLevel()">Ø§Ù„ØªØ§Ù„ÙŠ â–¶</button>
        </div>
    </div>
    <div class="reward-message" id="rewardMessage"></div>

    <script>
        // ---------- Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø±Ø§Ø­Ù„ ----------
        function generateLevels() {
            let levels = [];
            for (let i = 1; i <= 20; i++) {
                let cycle = Math.floor((i-1) / 5);
                let pos = (i-1) % 5; // 0,1,2,3,4
                let uniqueNumbers, obstacleCount, iceCount, arrowRate, bombRate;

                if (i <= 3) {
                    uniqueNumbers = 3; // Ø£Ø±Ù‚Ø§Ù… 1-3
                    obstacleCount = 0;
                    iceCount = 0;
                    arrowRate = 0.7;  // 70% ÙØ±ØµØ©
                    bombRate = 0.5;
                } else if (i <= 5) {
                    uniqueNumbers = 4; // Ø£Ø±Ù‚Ø§Ù… 1-4
                    obstacleCount = 2 + cycle;
                    iceCount = 1;
                    arrowRate = 0.3;
                    bombRate = 0.2;
                } else {
                    uniqueNumbers = 6; // Ø£Ø±Ù‚Ø§Ù… 1-6
                    obstacleCount = 4 + cycle * 2;
                    iceCount = 2 + cycle;
                    arrowRate = 0.1;
                    bombRate = 0.05;
                }

                levels.push({
                    id: i,
                    name: `Ù…Ø±Ø­Ù„Ø© ${i}`,
                    rows: (pos === 4 || i > 15) ? 7 : 6,
                    cols: (pos === 4 || i > 15) ? 7 : 6,
                    target: 400 + i * 50,
                    uniqueNumbers: uniqueNumbers,
                    obstacles: obstacleCount > 0 ? generateObstacles(obstacleCount, (pos===4||i>15)?7:6, (pos===4||i>15)?7:6) : [],
                    ice: iceCount > 0 ? generateIce(iceCount, (pos===4||i>15)?7:6, (pos===4||i>15)?7:6) : [],
                    arrowRate: arrowRate,
                    bombRate: bombRate,
                    shape: (pos === 4 && i > 10) ? 'triangle' : 'square'
                });
            }
            return levels;
        }

        function generateObstacles(count, rows, cols) {
            let obs = [];
            for (let i = 0; i < count; i++) {
                obs.push({ row: Math.floor(Math.random() * rows), col: Math.floor(Math.random() * cols) });
            }
            return obs;
        }
        function generateIce(count, rows, cols) {
            let ice = [];
            for (let i = 0; i < count; i++) {
                ice.push({ row: Math.floor(Math.random() * rows), col: Math.floor(Math.random() * cols), layers: 2 });
            }
            return ice;
        }

        const levels = generateLevels();
        let currentLevel = 0;
        let board = [];
        let score = 0;
        let selectedRow = -1, selectedCol = -1;
        let boosters = { arrow: 0, bomb: 0 };
        let selectedBooster = null;
        let hintTimer = null;
        let numbersPool = [];

        function updateNumbersPool(level) {
            numbersPool = [];
            for (let i = 1; i <= level.uniqueNumbers; i++) numbersPool.push(i);
        }

        function createRandomBoard(rows, cols) {
            let b = [];
            for (let r = 0; r < rows; r++) {
                let row = [];
                for (let c = 0; c < cols; c++) {
                    row.push(numbersPool[Math.floor(Math.random() * numbersPool.length)]);
                }
                b.push(row);
            }
            return b;
        }

        // ---------- Ø£Ø­Ø¯Ø§Ø« Ø§Ù„Ø³Ø­Ø¨ (Drag & Drop) ----------
        function handleDragStart(r, c) {
            if (!gameActive) return;
            selectedRow = r;
            selectedCol = c;
            renderBoard();
        }

        function handleDragOver(e) {
            e.preventDefault();
        }

        function handleDrop(r, c) {
            e.preventDefault();
            if (!gameActive || selectedRow === -1) return;
            if (Math.abs(r - selectedRow) + Math.abs(c - selectedCol) !== 1) {
                selectedRow = -1;
                renderBoard();
                return;
            }
            // ØªØ¨Ø¯ÙŠÙ„
            let temp = board[r][c];
            board[r][c] = board[selectedRow][selectedCol];
            board[selectedRow][selectedCol] = temp;
            processBoard();
            selectedRow = -1;
            renderBoard();
        }

        function processBoard() {
            let { matches, matchLengths } = checkMatches(board);
            if (matches.length > 0) {
                removeMatches(board, matches, matchLengths);
                let more;
                do {
                    let res = checkMatches(board);
                    more = res.matches;
                    if (more.length) removeMatches(board, more, res.matchLengths);
                } while (more.length);
            }
            renderBoard();
        }

        function checkMatches(board) {
            let matches = [], lengths = [];
            let rows = board.length, cols = board[0].length;
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols - 2; c++) {
                    if (board[r][c] && board[r][c+1] && board[r][c+2] && board[r][c] === board[r][c+1] && board[r][c] === board[r][c+2]) {
                        let len = 3;
                        if (c+3 < cols && board[r][c] === board[r][c+3]) len = 4;
                        if (c+4 < cols && board[r][c] === board[r][c+4]) len = 5;
                        for (let i = 0; i < len; i++) {
                            matches.push([r, c+i]);
                            lengths.push({ row: r, col: c+i, length: len });
                        }
                    }
                }
            }
            for (let c = 0; c < cols; c++) {
                for (let r = 0; r < rows - 2; r++) {
                    if (board[r][c] && board[r+1][c] && board[r+2][c] && board[r][c] === board[r+1][c] && board[r][c] === board[r+2][c]) {
                        let len = 3;
                        if (r+3 < rows && board[r][c] === board[r+3][c]) len = 4;
                        if (r+4 < rows && board[r][c] === board[r+4][c]) len = 5;
                        for (let i = 0; i < len; i++) {
                            matches.push([r+i, c]);
                            lengths.push({ row: r+i, col: c, length: len });
                        }
                    }
                }
            }
            return { matches: [...new Set(matches.map(JSON.stringify))].map(JSON.parse), matchLengths: lengths };
        }

        function removeMatches(board, matches, matchLengths) {
            let level = levels[currentLevel];
            let rows = board.length, cols = board[0].length;
            let removed = Array(rows).fill().map(() => Array(cols).fill(false));
            matches.forEach(([r, c]) => {
                removed[r][c] = true;
                let info = matchLengths.find(m => m.row === r && m.col === c);
                if (info) {
                    if (info.length === 4 && Math.random() < level.arrowRate) {
                        boosters.arrow++;
                        showMsg('ğŸ¯ Ø³Ù‡Ù…');
                    } else if (info.length === 5 && Math.random() < level.bombRate) {
                        boosters.bomb++;
                        showMsg('ğŸ’£ Ù‚Ù†Ø¨Ù„Ø©');
                    }
                }
            });
            score += matches.length * 10;

            for (let c = 0; c < cols; c++) {
                for (let r = rows-1; r >= 0; r--) {
                    if (removed[r][c]) {
                        for (let k = r-1; k >= 0; k--) {
                            if (!removed[k][c]) {
                                board[r][c] = board[k][c];
                                removed[k][c] = true;
                                removed[r][c] = false;
                                break;
                            }
                        }
                        if (removed[r][c]) board[r][c] = numbersPool[Math.floor(Math.random() * numbersPool.length)];
                    }
                }
            }
            if (score >= level.target) setTimeout(() => alert('ğŸ‰ ÙØ²Øª!'), 200);
        }

        // Ù…Ø³Ø§Ø¹Ø¯Ø© Ø¨Ø¹Ø¯ 10 Ø«ÙˆØ§Ù†ÙŠ
        function startHintTimer() {
            if (hintTimer) clearTimeout(hintTimer);
            hintTimer = setTimeout(() => {
                // Ø¥ÙŠØ¬Ø§Ø¯ Ø£ÙˆÙ„ Ø²ÙˆØ¬ Ù‚Ø§Ø¨Ù„ Ù„Ù„ØªØ¨Ø¯ÙŠÙ„ ÙŠØ¤Ø¯ÙŠ Ø¥Ù„Ù‰ ØªØ·Ø§Ø¨Ù‚
                for (let r = 0; r < board.length; r++) {
                    for (let c = 0; c < board[0].length; c++) {
                        if (c+1 < board[0].length) {
                            [board[r][c], board[r][c+1]] = [board[r][c+1], board[r][c]];
                            if (checkMatches(board).matches.length > 0) {
                                [board[r][c], board[r][c+1]] = [board[r][c+1], board[r][c]];
                                highlightHint(r, c);
                                return;
                            }
                            [board[r][c], board[r][c+1]] = [board[r][c+1], board[r][c]];
                        }
                        if (r+1 < board.length) {
                            [board[r][c], board[r+1][c]] = [board[r+1][c], board[r][c]];
                            if (checkMatches(board).matches.length > 0) {
                                [board[r][c], board[r+1][c]] = [board[r+1][c], board[r][c]];
                                highlightHint(r, c);
                                return;
                            }
                            [board[r][c], board[r+1][c]] = [board[r+1][c], board[r][c]];
                        }
                    }
                }
            }, 10000);
        }

        function highlightHint(r, c) {
            document.querySelectorAll('.cell').forEach(el => el.classList.remove('hint'));
            let idx = r * board[0].length + c;
            document.querySelectorAll('.cell')[idx]?.classList.add('hint');
        }

        function showMsg(t) {
            let m = document.getElementById('rewardMessage');
            m.textContent = t;
            m.style.display = 'block';
            setTimeout(() => m.style.display = 'none', 1500);
        }

        function renderBoard() {
            let level = levels[currentLevel];
            let boardDiv = document.getElementById('board');
            document.getElementById('levelNumber').innerText = `Ø§Ù„Ù…Ø³ØªÙˆÙ‰ ${level.id} / 20`;
            document.getElementById('target').innerText = level.target;
            document.getElementById('score').innerText = score;
            document.getElementById('arrowCount').innerText = boosters.arrow;
            document.getElementById('bombCount').innerText = boosters.bomb;

            boardDiv.style.gridTemplateColumns = `repeat(${level.cols}, 65px)`;
            boardDiv.innerHTML = '';

            for (let r = 0; r < level.rows; r++) {
                for (let c = 0; c < level.cols; c++) {
                    let cell = document.createElement('div');
                    cell.className = 'cell';
                    if (level.shape === 'triangle' && c > r) {
                        cell.classList.add('obstacle');
                    } else {
                        if (level.obstacles.some(o => o.row === r && o.col === c)) {
                            cell.classList.add('obstacle');
                        } else {
                            cell.textContent = board[r][c];
                            if (level.ice.some(i => i.row === r && i.col === c)) cell.classList.add('ice');
                        }
                    }
                    if (selectedRow === r && selectedCol === c) cell.classList.add('selected');
                    cell.setAttribute('draggable', 'true');
                    cell.ondragstart = (e) => { e.dataTransfer.setData('text/plain', ''); handleDragStart(r, c); };
                    cell.ondragover = (e) => e.preventDefault();
                    cell.ondrop = (e) => { e.preventDefault(); handleDrop(r, c); };
                    boardDiv.appendChild(cell);
                }
            }
            startHintTimer();
        }

        function selectBooster(type) {
            if (boosters[type] > 0) {
                selectedBooster = selectedBooster === type ? null : type;
                renderBoard();
            }
        }

        function nextLevel() {
            if (currentLevel < levels.length-1) currentLevel++;
            resetLevel();
        }
        function prevLevel() {
            if (currentLevel > 0) currentLevel--;
            resetLevel();
        }
        function resetLevel() {
            let level = levels[currentLevel];
            updateNumbersPool(level);
            board = createRandomBoard(level.rows, level.cols);
            score = 0;
            selectedRow = -1;
            selectedBooster = null;
            boosters = { arrow: level.id <= 3 ? 3 : level.id <=5 ? 1 : 0, bomb: level.id <= 3 ? 2 : level.id <=5 ? 1 : 0 };
            renderBoard();
        }

        resetLevel();
    </script>
</body>
</html>
