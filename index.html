<!DOCTYPE html>
<html dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Township Match-3 - Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø£ØµÙ„ÙŠØ©</title>
    <style>
        * {
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            user-select: none;
        }

        body {
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: radial-gradient(circle at 50% 50%, #0a1f2e, #051016);
            padding: 15px;
        }

        .game-container {
            background: linear-gradient(145deg, #1e3a5f, #0a1a2f);
            border-radius: 60px;
            padding: 25px;
            box-shadow: 0 30px 50px rgba(0,0,0,0.9), inset 0 0 30px rgba(255,215,0,0.1);
            max-width: 800px;
            width: 100%;
            border: 4px solid #c9a03d;
            position: relative;
        }

        /* Ø§Ù„Ù‡ÙŠØ¯Ø± */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            background: rgba(0,0,0,0.6);
            padding: 15px 25px;
            border-radius: 50px;
            border: 2px solid #c9a03d;
        }

        .level-box {
            background: linear-gradient(145deg, #c9a03d, #8b691f);
            color: white;
            padding: 10px 30px;
            border-radius: 40px;
            font-size: 28px;
            font-weight: bold;
            text-shadow: 2px 2px 0 #5a4513;
        }

        .score-box {
            background: #0a1a2f;
            color: #c9a03d;
            padding: 10px 30px;
            border-radius: 40px;
            font-size: 28px;
            font-weight: bold;
            border: 2px solid #c9a03d;
        }

        /* Ø§Ù„Ù…Ø¹Ø²Ø²Ø§Øª Ø§Ù„Ø¬Ø§Ù†Ø¨ÙŠØ© */
        .boosters-panel {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-bottom: 25px;
        }

        .booster-slot {
            width: 90px;
            height: 90px;
            background: #0a1a2f;
            border-radius: 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border: 3px solid #c9a03d;
            position: relative;
        }

        .booster-slot .count {
            position: absolute;
            top: -10px;
            right: -10px;
            background: #c9a03d;
            color: #0a1a2f;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 20px;
            border: 2px solid white;
        }

        .booster-icon {
            font-size: 40px;
        }

        /* Ù„ÙˆØ­Ø© Ø§Ù„Ù„Ø¹Ø¨ */
        .board-wrapper {
            background: #0a1a2f;
            padding: 25px;
            border-radius: 60px;
            border: 4px solid #c9a03d;
            margin-bottom: 25px;
            position: relative;
        }

        .board {
            display: inline-grid;
            gap: 8px;
            justify-content: center;
            width: 100%;
        }

        /* ØªØµÙ…ÙŠÙ… Ø§Ù„Ø£Ø­Ø¬Ø§Ø± Ø§Ù„ÙƒØ±ÙŠÙ…Ø© */
        .cell {
            width: 70px;
            height: 70px;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 0 rgba(0,0,0,0.5);
            box-shadow: 0 8px 0 rgba(0,0,0,0.3), 0 10px 15px rgba(0,0,0,0.4);
            cursor: pointer;
            transition: 0.05s;
            position: relative;
            border: 2px solid rgba(255,255,255,0.3);
        }

        .cell:active {
            transform: scale(0.95);
        }

        .cell.selected {
            transform: scale(1.1);
            box-shadow: 0 0 0 6px #c9a03d, 0 8px 0 rgba(0,0,0,0.3), 0 15px 25px black;
            z-index: 100;
        }

        /* Ø£Ù„ÙˆØ§Ù† Ø§Ù„Ø£Ø­Ø¬Ø§Ø± */
        .gem-red { background: radial-gradient(circle at 30% 30%, #ff4d4d, #b30000); }
        .gem-green { background: radial-gradient(circle at 30% 30%, #4dff4d, #00b300); }
        .gem-blue { background: radial-gradient(circle at 30% 30%, #4d4dff, #0000b3); }
        .gem-yellow { background: radial-gradient(circle at 30% 30%, #ffff4d, #b3b300); }
        .gem-purple { background: radial-gradient(circle at 30% 30%, #ff4dff, #b300b3); }
        .gem-orange { background: radial-gradient(circle at 30% 30%, #ffaa4d, #b35f00); }

        /* ØªØµÙ…ÙŠÙ… Ø§Ù„Ù…Ø¹Ø²Ø²Ø§Øª Ø¯Ø§Ø®Ù„ Ø§Ù„Ù„Ø¹Ø¨Ø© */
        .booster-piece {
            width: 70px;
            height: 70px;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            cursor: pointer;
            animation: boosterAppear 0.3s;
            box-shadow: 0 0 20px gold;
            border: 3px solid white;
        }

        .booster-piece.rocket {
            background: linear-gradient(145deg, #ffaa4d, #ff6b4d);
        }

        .booster-piece.bomb {
            background: radial-gradient(circle at 30% 30%, #4d4d4d, #1a1a1a);
        }

        .booster-piece.rainbow {
            background: linear-gradient(145deg, #ff4d4d, #ff4dff, #4d4dff, #4dff4d, #ffff4d);
        }

        .booster-piece.dynamite {
            background: radial-gradient(circle at 30% 30%, #ff4d4d, #b30000);
        }

        @keyframes boosterAppear {
            0% { transform: scale(0); opacity: 0; }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); opacity: 1; }
        }

        @keyframes matchPop {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); filter: brightness(1.5); }
            100% { transform: scale(0); opacity: 0; }
        }

        .cell.matching {
            animation: matchPop 0.2s ease forwards;
            pointer-events: none;
        }

        /* Ø´Ø§Ø´Ø© Ø§Ù„ÙÙˆØ² */
        .victory-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            backdrop-filter: blur(10px);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            border-radius: 60px;
        }

        .victory-content {
            background: linear-gradient(145deg, #c9a03d, #8b691f);
            padding: 50px;
            border-radius: 80px;
            text-align: center;
            color: white;
            border: 5px solid white;
        }

        .victory-content h1 {
            font-size: 60px;
            margin-bottom: 20px;
        }

        .victory-content button {
            background: #0a1a2f;
            color: #c9a03d;
            border: none;
            padding: 20px 50px;
            font-size: 32px;
            border-radius: 60px;
            cursor: pointer;
            margin-top: 30px;
            border: 3px solid white;
        }

        /* Ø²Ø± Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© */
        .hint-btn {
            background: linear-gradient(145deg, #c9a03d, #8b691f);
            color: white;
            font-size: 24px;
            padding: 15px 30px;
            border-radius: 50px;
            border: none;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin: 0 auto 20px;
            width: fit-content;
            box-shadow: 0 8px 0 #5a4513;
            transition: 0.05s;
        }

        .hint-btn:active {
            transform: translateY(4px);
            box-shadow: 0 4px 0 #5a4513;
        }

        .cell.hint {
            animation: hintPulse 0.8s infinite;
            box-shadow: 0 0 0 6px cyan, 0 8px 0 rgba(0,0,0,0.3);
        }

        @keyframes hintPulse {
            0% { filter: brightness(1); }
            50% { filter: brightness(1.5); }
        }

        /* Ø£Ø²Ø±Ø§Ø± Ø§Ù„ØªÙ†Ù‚Ù„ */
        .nav-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
        }

        .nav-btn {
            background: linear-gradient(145deg, #1e3a5f, #0a1a2f);
            border: 3px solid #c9a03d;
            color: #c9a03d;
            font-size: 24px;
            padding: 12px 25px;
            border-radius: 50px;
            cursor: pointer;
            transition: 0.05s;
            box-shadow: 0 6px 0 #051016;
            flex: 1;
            max-width: 180px;
            text-align: center;
        }

        .nav-btn:active {
            transform: translateY(4px);
            box-shadow: 0 2px 0 #051016;
        }

        .nav-btn.disabled {
            opacity: 0.3;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <!-- Ø§Ù„Ù‡ÙŠØ¯Ø± -->
        <div class="header">
            <div class="level-box" id="levelDisplay">Ø§Ù„Ù…Ø³ØªÙˆÙ‰ 1</div>
            <div class="score-box" id="scoreDisplay">0</div>
        </div>

        <!-- Ø§Ù„Ù…Ø¹Ø²Ø²Ø§Øª Ø§Ù„Ø¬Ø§Ù†Ø¨ÙŠØ© -->
        <div class="boosters-panel">
            <div class="booster-slot" id="boosterRocketSlot">
                <div class="booster-icon">ğŸš€</div>
                <div class="count" id="rocketCount">0</div>
            </div>
            <div class="booster-slot" id="boosterBombSlot">
                <div class="booster-icon">ğŸ’£</div>
                <div class="count" id="bombCount">0</div>
            </div>
            <div class="booster-slot" id="boosterRainbowSlot">
                <div class="booster-icon">ğŸŒˆ</div>
                <div class="count" id="rainbowCount">0</div>
            </div>
        </div>

        <!-- Ø²Ø± Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© -->
        <button class="hint-btn" onclick="useHint()">
            <span>ğŸ”</span> Ù…Ø³Ø§Ø¹Ø¯Ø©
        </button>

        <!-- Ù„ÙˆØ­Ø© Ø§Ù„Ù„Ø¹Ø¨ -->
        <div class="board-wrapper" id="boardWrapper">
            <div class="board" id="board"></div>
        </div>

        <!-- Ø´Ø§Ø´Ø© Ø§Ù„ÙÙˆØ² -->
        <div class="victory-screen" id="victoryScreen">
            <div class="victory-content">
                <h1>ğŸ‰ LEVEL COMPLETE! ğŸ‰</h1>
                <div style="font-size: 60px; margin: 20px 0;" id="victoryStars">â˜…â˜…â˜…</div>
                <button onclick="goToNextLevel()">NEXT LEVEL â–¶</button>
            </div>
        </div>

        <!-- Ø£Ø²Ø±Ø§Ø± Ø§Ù„ØªÙ†Ù‚Ù„ -->
        <div class="nav-buttons">
            <div class="nav-btn" onclick="prevLevel()" id="prevBtn">â—€ PREV</div>
            <div class="nav-btn" onclick="resetLevel()">ğŸ”„ RESET</div>
            <div class="nav-btn" onclick="nextLevel()" id="nextBtn">NEXT â–¶</div>
        </div>
    </div>

    <script>
        // ------------------------------------------------------------
        //                     TOWNSHIP MATCH-3 ORIGINAL
        // ------------------------------------------------------------

        // Ø§Ù„Ø£Ù„ÙˆØ§Ù† (Ø§Ù„Ø£Ø­Ø¬Ø§Ø±)
        const GEM_TYPES = ['red', 'green', 'blue', 'yellow', 'purple', 'orange'];
        const GEM_VALUES = {
            'red': 1,
            'green': 2,
            'blue': 3,
            'yellow': 4,
            'purple': 5,
            'orange': 6
        };

        // Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ù…Ø¹Ø²Ø²Ø§Øª
        const BOOSTER_TYPES = {
            ROCKET: 'rocket',     // ØµØ§Ø±ÙˆØ® (4 ÙÙŠ Ø®Ø·)
            BOMB: 'bomb',         // Ù‚Ù†Ø¨Ù„Ø© (2x2 Ù…Ø±Ø¨Ø¹)
            RAINBOW: 'rainbow',   // Ù‚ÙˆØ³ Ù‚Ø²Ø­ (5 ÙÙŠ Ø®Ø·)
            DYNAMITE: 'dynamite'  // Ù…ØªÙØ¬Ø± (5 Ø¹Ù„Ù‰ Ø´ÙƒÙ„ L Ø£Ùˆ T)
        };

        // ------------------------------------------------------------
        //                     Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù„Ø¹Ø¨Ø©
        // ------------------------------------------------------------

        let currentLevel = 0;
        let board = [];
        let score = 0;
        let selectedRow = -1, selectedCol = -1;
        let gamePaused = false;

        // Ø§Ù„Ù…Ø¹Ø²Ø²Ø§Øª Ø§Ù„Ø¬Ø§Ù†Ø¨ÙŠØ© (Ø§Ù„Ù„ÙŠ ÙŠØ¬Ù…Ø¹Ù‡Ø§ Ø§Ù„Ù„Ø§Ø¹Ø¨)
        let sideBoosters = {
            rocket: 0,
            bomb: 0,
            rainbow: 0
        };

        // Ø§Ù„Ù…Ø¹Ø²Ø²Ø§Øª Ø¯Ø§Ø®Ù„ Ø§Ù„Ù„Ø¹Ø¨Ø© (Ø§Ù„Ù„ÙŠ ØªØ¸Ù‡Ø± Ø¹Ù„Ù‰ Ø§Ù„Ù„ÙˆØ­Ø©)
        let boardBoosters = []; // { row, col, type }

        // Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª Ø§Ù„Ù…Ø­Ù„ÙˆÙ„Ø©
        let completedLevels = JSON.parse(localStorage.getItem('completedLevels')) || [];

        // ------------------------------------------------------------
        //                     ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ù…Ø±Ø§Ø­Ù„
        // ------------------------------------------------------------
        const levels = [
            // Ø§Ù„Ù…Ø±Ø­Ù„Ø© 1: 6x6, 4 Ø£Ù„ÙˆØ§Ù†
            { id: 1, rows: 6, cols: 6, colors: 4, target: 500, obstacles: [], ice: [] },
            // Ø§Ù„Ù…Ø±Ø­Ù„Ø© 2: 6x6, 4 Ø£Ù„ÙˆØ§Ù† + ØµØ®ÙˆØ±
            { id: 2, rows: 6, cols: 6, colors: 4, target: 600, 
              obstacles: [[1,1], [1,4], [3,2], [4,5]], ice: [] },
            // Ø§Ù„Ù…Ø±Ø­Ù„Ø© 3: 6x6, 5 Ø£Ù„ÙˆØ§Ù†
            { id: 3, rows: 6, cols: 6, colors: 5, target: 700, obstacles: [], ice: [] },
            // Ø§Ù„Ù…Ø±Ø­Ù„Ø© 4: 6x6, 5 Ø£Ù„ÙˆØ§Ù† + Ø¬Ù„ÙŠØ¯
            { id: 4, rows: 6, cols: 6, colors: 5, target: 800,
              obstacles: [], ice: [[0,0], [0,5], [5,0], [5,5]] },
            // Ø§Ù„Ù…Ø±Ø­Ù„Ø© 5: 7x7, 6 Ø£Ù„ÙˆØ§Ù† + ØµØ®ÙˆØ± + Ø¬Ù„ÙŠØ¯
            { id: 5, rows: 7, cols: 7, colors: 6, target: 1000,
              obstacles: [[1,1], [1,5], [3,3], [5,1], [5,5]],
              ice: [[0,0], [0,6], [6,0], [6,6]] }
        ];

        // ------------------------------------------------------------
        //                     Ø¥Ù†Ø´Ø§Ø¡ Ù„ÙˆØ­Ø© Ø¹Ø´ÙˆØ§Ø¦ÙŠØ©
        // ------------------------------------------------------------
        function createBoard(level) {
            let newBoard = [];
            let availableColors = GEM_TYPES.slice(0, level.colors);
            
            for (let r = 0; r < level.rows; r++) {
                let row = [];
                for (let c = 0; c < level.cols; c++) {
                    // ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª ØµØ®Ø±Ø©
                    if (level.obstacles.some(([obR, obC]) => obR === r && obC === c)) {
                        row.push('obstacle');
                    } else {
                        let randomColor = availableColors[Math.floor(Math.random() * availableColors.length)];
                        row.push(randomColor);
                    }
                }
                newBoard.push(row);
            }
            
            // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø¹Ø¯Ù… ÙˆØ¬ÙˆØ¯ ØªØ·Ø§Ø¨Ù‚Ø§Øª Ø£ÙˆÙ„ÙŠØ©
            while (hasInitialMatches(newBoard)) {
                for (let r = 0; r < level.rows; r++) {
                    for (let c = 0; c < level.cols; c++) {
                        if (!level.obstacles.some(([obR, obC]) => obR === r && obC === c)) {
                            let randomColor = availableColors[Math.floor(Math.random() * availableColors.length)];
                            newBoard[r][c] = randomColor;
                        }
                    }
                }
            }
            
            return newBoard;
        }

        function hasInitialMatches(board) {
            let rows = board.length, cols = board[0].length;
            
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols - 2; c++) {
                    if (board[r][c] !== 'obstacle' && board[r][c] === board[r][c+1] && board[r][c] === board[r][c+2]) {
                        return true;
                    }
                }
            }
            
            for (let c = 0; c < cols; c++) {
                for (let r = 0; r < rows - 2; r++) {
                    if (board[r][c] !== 'obstacle' && board[r][c] === board[r+1][c] && board[r][c] === board[r+2][c]) {
                        return true;
                    }
                }
            }
            
            return false;
        }

        // ------------------------------------------------------------
        //                     Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªØ·Ø§Ø¨Ù‚Ø§Øª
        // ------------------------------------------------------------
        function checkMatches(board) {
            let matches = [];
            let matchGroups = []; // ÙƒÙ„ Ù…Ø¬Ù…ÙˆØ¹Ø© ØªØ·Ø§Ø¨Ù‚ Ø¹Ù„Ù‰ Ø­Ø¯Ø©
            let rows = board.length, cols = board[0].length;
            let processed = Array(rows).fill().map(() => Array(cols).fill(false));

            // Ø£ÙÙ‚ÙŠ
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols - 2; c++) {
                    if (board[r][c] === 'obstacle') continue;
                    
                    let color = board[r][c];
                    let len = 1;
                    while (c + len < cols && board[r][c + len] === color) len++;
                    
                    if (len >= 3) {
                        let group = [];
                        for (let i = 0; i < len; i++) {
                            if (!processed[r][c + i]) {
                                group.push([r, c + i]);
                                processed[r][c + i] = true;
                            }
                        }
                        if (group.length >= 3) {
                            matchGroups.push({
                                cells: group,
                                color: color,
                                length: len,
                                isHorizontal: true,
                                startRow: r,
                                startCol: c
                            });
                            matches.push(...group);
                        }
                    }
                    c += len - 1;
                }
            }

            // Ø¹Ù…ÙˆØ¯ÙŠ
            processed = Array(rows).fill().map(() => Array(cols).fill(false));
            for (let c = 0; c < cols; c++) {
                for (let r = 0; r < rows - 2; r++) {
                    if (board[r][c] === 'obstacle') continue;
                    
                    let color = board[r][c];
                    let len = 1;
                    while (r + len < rows && board[r + len][c] === color) len++;
                    
                    if (len >= 3) {
                        let group = [];
                        for (let i = 0; i < len; i++) {
                            if (!processed[r + i][c]) {
                                group.push([r + i, c]);
                                processed[r + i][c] = true;
                            }
                        }
                        if (group.length >= 3) {
                            matchGroups.push({
                                cells: group,
                                color: color,
                                length: len,
                                isHorizontal: false,
                                startRow: r,
                                startCol: c
                            });
                            matches.push(...group);
                        }
                    }
                    r += len - 1;
                }
            }

            return { matches, matchGroups };
        }

        // ------------------------------------------------------------
        //                     Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø¹Ø²Ø² Ø­Ø³Ø¨ Ø´ÙƒÙ„ Ø§Ù„ØªØ·Ø§Ø¨Ù‚
        // ------------------------------------------------------------
        function createBoosterFromMatch(group) {
            let { cells, length, isHorizontal, startRow, startCol, color } = group;
            
            // ØªØ·Ø§Ø¨Ù‚ 5 Ø£Ø­Ø¬Ø§Ø±
            if (length >= 5) {
                // ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø´ÙƒÙ„ L Ø£Ùˆ T
                let isLShape = false;
                let isTShape = false;
                
                // Ù‡Ø°Ø§ ØªØ¨Ø³ÙŠØ· - ÙÙŠ Ø§Ù„ÙˆØ§Ù‚Ø¹ Ù„Ø§Ø²Ù… ØªØ­Ù‚Ù‚ Ø¯Ù‚ÙŠÙ‚ Ù„Ù„Ø´ÙƒÙ„
                if (cells.length >= 5) {
                    // Ø§ÙØªØ±Ø¶ Ø£Ù†Ù‡Ø§ ÙƒØ±Ø© Ù‚ÙˆØ³ Ù‚Ø²Ø­ Ù„Ù„ØªØ¨Ø³ÙŠØ·
                    return {
                        type: BOOSTER_TYPES.RAINBOW,
                        row: cells[2][0],
                        col: cells[2][1]
                    };
                }
            }
            
            // ØªØ·Ø§Ø¨Ù‚ 4 Ø£Ø­Ø¬Ø§Ø±
            if (length === 4) {
                // ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…Ø±Ø¨Ø¹ 2x2
                let isSquare = false;
                // Ù‡Ø°Ø§ ØªØ¨Ø³ÙŠØ· - ÙÙŠ Ø§Ù„ÙˆØ§Ù‚Ø¹ Ù„Ø§Ø²Ù… ØªØ­Ù‚Ù‚
                
                if (isHorizontal) {
                    // ØµØ§Ø±ÙˆØ® Ø£ÙÙ‚ÙŠ
                    return {
                        type: BOOSTER_TYPES.ROCKET,
                        row: startRow,
                        col: Math.floor(startCol + length/2),
                        direction: 'horizontal'
                    };
                } else {
                    // ØµØ§Ø±ÙˆØ® Ø¹Ù…ÙˆØ¯ÙŠ
                    return {
                        type: BOOSTER_TYPES.ROCKET,
                        row: Math.floor(startRow + length/2),
                        col: startCol,
                        direction: 'vertical'
                    };
                }
            }
            
            return null;
        }

        // ------------------------------------------------------------
        //                     Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØªØ·Ø§Ø¨Ù‚Ø§Øª
        // ------------------------------------------------------------
        async function removeMatchesAndDrop(board, matches, matchGroups) {
            if (gamePaused) return;
            
            let level = levels[currentLevel];
            let rows = board.length, cols = board[0].length;
            let totalPoints = 0;
            let newBoosters = [];

            // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù†Ù‚Ø§Ø· ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø¹Ø²Ø²Ø§Øª
            matchGroups.forEach(group => {
                let points = group.cells.length * GEM_VALUES[group.color];
                totalPoints += points;
                
                // Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø¹Ø²Ø² Ø¥Ø°Ø§ ÙƒØ§Ù† ØªØ·Ø§Ø¨Ù‚ 4 Ø£Ùˆ 5
                if (group.length >= 4) {
                    let booster = createBoosterFromMatch(group);
                    if (booster) {
                        newBoosters.push(booster);
                    }
                }
            });

            // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù†Ù‚Ø§Ø·
            score += totalPoints;

            // ØªØ£Ø«ÙŠØ± Ø§Ù„Ø§Ù†ÙØ¬Ø§Ø±
            let cells = document.querySelectorAll('.cell');
            matches.forEach(([r, c]) => {
                let index = r * cols + c;
                if (cells[index]) cells[index].classList.add('matching');
            });

            await new Promise(resolve => setTimeout(resolve, 200));

            // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ø®Ù„Ø§ÙŠØ§ Ø§Ù„Ù…ØªØ·Ø§Ø¨Ù‚Ø©
            let removed = Array(rows).fill().map(() => Array(cols).fill(false));
            matches.forEach(([r, c]) => {
                if (board[r][c] !== 'obstacle') {
                    board[r][c] = null;
                    removed[r][c] = true;
                }
            });

            // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø¹Ø²Ø²Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
            newBoosters.forEach(booster => {
                boardBoosters.push(booster);
            });

            // Ø¥Ø³Ù‚Ø§Ø· Ø§Ù„Ø£Ø­Ø¬Ø§Ø± Ù…Ù† Ø§Ù„Ø£Ø¹Ù„Ù‰
            for (let c = 0; c < cols; c++) {
                for (let r = rows - 1; r >= 0; r--) {
                    if (removed[r][c]) {
                        // Ø¥Ø³Ù‚Ø§Ø· Ø§Ù„Ø£Ø­Ø¬Ø§Ø± Ù…Ù† ÙÙˆÙ‚
                        for (let k = r - 1; k >= 0; k--) {
                            if (board[k][c] && board[k][c] !== 'obstacle' && !removed[k][c]) {
                                board[r][c] = board[k][c];
                                board[k][c] = null;
                                removed[k][c] = true;
                                removed[r][c] = false;
                                break;
                            }
                        }
                        // Ø¥Ø°Ø§ Ù„Ù… Ù†Ø¬Ø¯ Ø­Ø¬Ø± Ù†Ø³Ù‚Ø·Ù‡ØŒ Ù†Ù†Ø´Ø¦ Ø­Ø¬Ø± Ø¬Ø¯ÙŠØ¯
                        if (removed[r][c]) {
                            let availableColors = GEM_TYPES.slice(0, level.colors);
                            board[r][c] = availableColors[Math.floor(Math.random() * availableColors.length)];
                        }
                    }
                }
            }

            renderBoard();

            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØªØ·Ø§Ø¨Ù‚Ø§Øª Ø¬Ø¯ÙŠØ¯Ø©
            await new Promise(resolve => setTimeout(resolve, 300));
            let { matches: newMatches, matchGroups: newGroups } = checkMatches(board);
            if (newMatches.length > 0) {
                await removeMatchesAndDrop(board, newMatches, newGroups);
            }

            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ÙÙˆØ²
            if (score >= level.target && !completedLevels.includes(currentLevel)) {
                gamePaused = true;
                completedLevels.push(currentLevel);
                localStorage.setItem('completedLevels', JSON.stringify(completedLevels));
                document.getElementById('victoryScreen').style.display = 'flex';
            }
        }

        // ------------------------------------------------------------
        //                     Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…Ø¹Ø²Ø²Ø§Øª
        // ------------------------------------------------------------
        function useBoosterFromBoard(row, col, booster) {
            let index = boardBoosters.findIndex(b => b.row === row && b.col === col);
            if (index === -1) return;
            
            boardBoosters.splice(index, 1);
            
            switch(booster.type) {
                case BOOSTER_TYPES.ROCKET:
                    useRocket(booster.row, booster.col, booster.direction);
                    break;
                case BOOSTER_TYPES.BOMB:
                    useBomb(booster.row, booster.col);
                    break;
                case BOOSTER_TYPES.RAINBOW:
                    useRainbow(booster.row, booster.col);
                    break;
            }
        }

        function useRocket(row, col, direction) {
            let level = levels[currentLevel];
            let rows = board.length, cols = board[0].length;
            let points = 0;
            
            if (direction === 'horizontal') {
                for (let c = 0; c < cols; c++) {
                    if (board[row][c] && board[row][c] !== 'obstacle') {
                        points += GEM_VALUES[board[row][c]];
                        board[row][c] = null;
                    }
                }
            } else {
                for (let r = 0; r < rows; r++) {
                    if (board[r][col] && board[r][col] !== 'obstacle') {
                        points += GEM_VALUES[board[r][col]];
                        board[r][col] = null;
                    }
                }
            }
            
            score += points;
            showMessage(`ğŸš€ +${points}`);
            renderBoard();
            
            // Ø³Ù‚ÙˆØ· Ø§Ù„Ø£Ø­Ø¬Ø§Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
            setTimeout(async () => {
                let { matches, matchGroups } = checkMatches(board);
                if (matches.length > 0) {
                    await removeMatchesAndDrop(board, matches, matchGroups);
                }
            }, 300);
        }

        function useBomb(row, col) {
            let level = levels[currentLevel];
            let rows = board.length, cols = board[0].length;
            let points = 0;
            
            for (let r = Math.max(0, row-1); r <= Math.min(rows-1, row+1); r++) {
                for (let c = Math.max(0, col-1); c <= Math.min(cols-1, col+1); c++) {
                    if (board[r][c] && board[r][c] !== 'obstacle') {
                        points += GEM_VALUES[board[r][c]];
                        board[r][c] = null;
                    }
                }
            }
            
            score += points;
            showMessage(`ğŸ’£ +${points}`);
            renderBoard();
            
            setTimeout(async () => {
                let { matches, matchGroups } = checkMatches(board);
                if (matches.length > 0) {
                    await removeMatchesAndDrop(board, matches, matchGroups);
                }
            }, 300);
        }

        function useRainbow(row, col) {
            let level = levels[currentLevel];
            let color = board[row][col];
            let points = 0;
            
            for (let r = 0; r < board.length; r++) {
                for (let c = 0; c < board[0].length; c++) {
                    if (board[r][c] === color) {
                        points += GEM_VALUES[color];
                        board[r][c] = null;
                    }
                }
            }
            
            score += points;
            showMessage(`ğŸŒˆ +${points}`);
            renderBoard();
            
            setTimeout(async () => {
                let { matches, matchGroups } = checkMatches(board);
                if (matches.length > 0) {
                    await removeMatchesAndDrop(board, matches, matchGroups);
                }
            }, 300);
        }

        // ------------------------------------------------------------
        //                     Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©
        // ------------------------------------------------------------
        function useHint() {
            if (gamePaused) return;
            
            // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø£ÙˆÙ„ Ø­Ø±ÙƒØ© Ù…ÙÙŠØ¯Ø©
            for (let r = 0; r < board.length; r++) {
                for (let c = 0; c < board[0].length; c++) {
                    if (board[r][c] === 'obstacle') continue;
                    
                    // Ø¬Ø±Ø¨ Ø§Ù„ØªØ¨Ø¯ÙŠÙ„ Ù…Ø¹ Ø§Ù„ÙŠÙ…ÙŠÙ†
                    if (c + 1 < board[0].length && board[r][c+1] !== 'obstacle') {
                        [board[r][c], board[r][c+1]] = [board[r][c+1], board[r][c]];
                        if (checkMatches(board).matches.length > 0) {
                            [board[r][c], board[r][c+1]] = [board[r][c+1], board[r][c]];
                            highlightCell(r, c);
                            return;
                        }
                        [board[r][c], board[r][c+1]] = [board[r][c+1], board[r][c]];
                    }
                    
                    // Ø¬Ø±Ø¨ Ø§Ù„ØªØ¨Ø¯ÙŠÙ„ Ù…Ø¹ Ø§Ù„Ø£Ø³ÙÙ„
                    if (r + 1 < board.length && board[r+1][c] !== 'obstacle') {
                        [board[r][c], board[r+1][c]] = [board[r+1][c], board[r][c]];
                        if (checkMatches(board).matches.length > 0) {
                            [board[r][c], board[r+1][c]] = [board[r+1][c], board[r][c]];
                            highlightCell(r, c);
                            return;
                        }
                        [board[r][c], board[r+1][c]] = [board[r+1][c], board[r][c]];
                    }
                }
            }
            
            showMessage('âŒ No moves available');
        }

        function highlightCell(r, c) {
            let index = r * board[0].length + c;
            document.querySelectorAll('.cell')[index]?.classList.add('hint');
            setTimeout(() => {
                document.querySelectorAll('.cell').forEach(el => el.classList.remove('hint'));
            }, 2000);
        }

        // ------------------------------------------------------------
        //                     Ø§Ù„Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ø§Ù„Ø®Ù„ÙŠØ©
        // ------------------------------------------------------------
        async function handleCellClick(r, c) {
            if (gamePaused) return;
            
            let level = levels[currentLevel];
            
            // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª ØµØ®Ø±Ø©
            if (board[r][c] === 'obstacle') return;
            
            // Ø¥Ø°Ø§ ÙƒØ§Ù† ÙÙŠ Ù…Ø¹Ø²Ø² Ø¹Ù„Ù‰ Ø§Ù„Ù„ÙˆØ­Ø©
            let booster = boardBoosters.find(b => b.row === r && b.col === c);
            if (booster) {
                useBoosterFromBoard(r, c, booster);
                return;
            }
            
            // Ø£ÙˆÙ„ Ø§Ø®ØªÙŠØ§Ø±
            if (selectedRow === -1) {
                selectedRow = r;
                selectedCol = c;
                renderBoard();
                return;
            }
            
            // ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªØ¬Ø§ÙˆØ±
            let rowDiff = Math.abs(r - selectedRow);
            let colDiff = Math.abs(c - selectedCol);
            let isAdjacent = (rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1);
            
            if (isAdjacent) {
                // ØªØ¨Ø¯ÙŠÙ„
                [board[r][c], board[selectedRow][selectedCol]] = [board[selectedRow][selectedCol], board[r][c]];
                
                let { matches, matchGroups } = checkMatches(board);
                
                if (matches.length > 0) {
                    await removeMatchesAndDrop(board, matches, matchGroups);
                } else {
                    // Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ¨Ø¯ÙŠÙ„
                    [board[r][c], board[selectedRow][selectedCol]] = [board[selectedRow][selectedCol], board[r][c]];
                    
                    // ØªØ£Ø«ÙŠØ± Ø®Ø·Ø£
                    document.querySelectorAll('.cell').forEach(cell => cell.classList.add('error'));
                    setTimeout(() => document.querySelectorAll('.cell').forEach(cell => cell.classList.remove('error')), 200);
                }
            }
            
            selectedRow = -1;
            selectedCol = -1;
            renderBoard();
        }

        // ------------------------------------------------------------
        //                     Ø¹Ø±Ø¶ Ø§Ù„Ù„ÙˆØ­Ø©
        // ------------------------------------------------------------
        function renderBoard() {
            let level = levels[currentLevel];
            let boardDiv = document.getElementById('board');
            
            document.getElementById('levelDisplay').textContent = `LEVEL ${level.id}`;
            document.getElementById('scoreDisplay').textContent = score;
            
            // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø¹Ø²Ø²Ø§Øª Ø§Ù„Ø¬Ø§Ù†Ø¨ÙŠØ©
            document.getElementById('rocketCount').textContent = sideBoosters.rocket;
            document.getElementById('bombCount').textContent = sideBoosters.bomb;
            document.getElementById('rainbowCount').textContent = sideBoosters.rainbow;
            
            // ØªØ­Ø¯ÙŠØ« Ø£Ø²Ø±Ø§Ø± Ø§Ù„ØªÙ†Ù‚Ù„
            document.getElementById('prevBtn').classList.toggle('disabled', currentLevel === 0);
            document.getElementById('nextBtn').classList.toggle('disabled', 
                currentLevel === levels.length - 1 || !completedLevels.includes(currentLevel));
            
            boardDiv.style.gridTemplateColumns = `repeat(${level.cols}, 70px)`;
            boardDiv.innerHTML = '';
            
            for (let r = 0; r < level.rows; r++) {
                for (let c = 0; c < level.cols; c++) {
                    let cell = document.createElement('div');
                    cell.className = 'cell';
                    
                    // ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ù…Ø¹Ø²Ø²
                    let booster = boardBoosters.find(b => b.row === r && b.col === c);
                    
                    if (booster) {
                        cell.classList.add('booster-piece', booster.type);
                        switch(booster.type) {
                            case 'rocket':
                                cell.textContent = booster.direction === 'horizontal' ? 'â¡ï¸' : 'â¬‡ï¸';
                                break;
                            case 'bomb':
                                cell.textContent = 'ğŸ’£';
                                break;
                            case 'rainbow':
                                cell.textContent = 'ğŸŒˆ';
                                break;
                        }
                    } else if (board[r][c] === 'obstacle') {
                        cell.classList.add('obstacle');
                        cell.textContent = 'â›”';
                    } else {
                        cell.textContent = 'ğŸ’';
                        cell.classList.add(`gem-${board[r][c]}`);
                    }
                    
                    if (selectedRow === r && selectedCol === c && !booster) {
                        cell.classList.add('selected');
                    }
                    
                    cell.onclick = () => handleCellClick(r, c);
                    boardDiv.appendChild(cell);
                }
            }
        }

        // ------------------------------------------------------------
        //                     Ø§Ù„ØªÙ†Ù‚Ù„ Ø¨ÙŠÙ† Ø§Ù„Ù…Ø±Ø§Ø­Ù„
        // ------------------------------------------------------------
        function nextLevel() {
            if (currentLevel < levels.length - 1 && completedLevels.includes(currentLevel)) {
                currentLevel++;
                resetLevel();
            }
        }

        function prevLevel() {
            if (currentLevel > 0) {
                currentLevel--;
                resetLevel();
            }
        }

        function goToNextLevel() {
            document.getElementById('victoryScreen').style.display = 'none';
            if (currentLevel < levels.length - 1) {
                currentLevel++;
                resetLevel();
            }
        }

        function resetLevel() {
            let level = levels[currentLevel];
            board = createBoard(level);
            score = 0;
            selectedRow = -1;
            selectedCol = -1;
            boardBoosters = [];
            sideBoosters = { rocket: 0, bomb: 0, rainbow: 0 };
            gamePaused = false;
            renderBoard();
        }

        function showMessage(text) {
            // ÙŠÙ…ÙƒÙ† Ø¥Ø¶Ø§ÙØ© Ø±Ø³Ø§Ù„Ø© Ù…Ù†Ø¨Ø«Ù‚Ø© Ù‡Ù†Ø§
            console.log(text);
        }

        // Ø¨Ø¯Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø©
        resetLevel();
    </script>
</body>
</html>
